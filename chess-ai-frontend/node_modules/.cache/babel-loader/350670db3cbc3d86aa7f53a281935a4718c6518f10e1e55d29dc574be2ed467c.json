{"ast":null,"code":"var _jsxFileName = \"/Users/bignola/Desktop/School/Capstone/AI-Chess-main/chess-ai-frontend/src/components/ChessBoard/ChessBoard.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { Chessboard } from 'react-chessboard';\nimport { Chess } from 'chess.js';\nimport './ChessBoard.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChessBoard = ({\n  onGameEnd\n}) => {\n  _s();\n  const [game, setGame] = useState(() => new Chess());\n  const [boardOrientation, setBoardOrientation] = useState('white');\n  const [isAIThinking, setIsAIThinking] = useState(false);\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [playerColor, setPlayerColor] = useState('white'); // Player plays as white by default\n  const [selectedSquare, setSelectedSquare] = useState(null);\n  const [legalMoveSquares, setLegalMoveSquares] = useState({});\n\n  // Debug function to show all legal moves from a position\n  function showLegalMoves(sourceSquare) {\n    if (!sourceSquare) return [];\n\n    // Get all legal moves for the piece at the source square\n    const legalMoves = game.moves({\n      square: sourceSquare,\n      verbose: true\n    });\n    console.log(`Legal moves from ${sourceSquare}:`, legalMoves);\n    return legalMoves;\n  }\n\n  // Function to directly apply a move without chess.js's move validation\n  // This is a last resort for when chess.js is changing the user's move\n  function directMove(sourceSquare, targetSquare) {\n    console.log(\"Attempting direct move from\", sourceSquare, \"to\", targetSquare);\n\n    // Create a new game state from the current position\n    const currentFEN = game.fen();\n    const gameCopy = new Chess(currentFEN);\n    console.log(\"Starting position:\", currentFEN);\n\n    // Get the piece at the source square\n    const piece = gameCopy.get(sourceSquare);\n    if (!piece) {\n      console.error(\"No piece at source square:\", sourceSquare);\n      return false;\n    }\n\n    // Get all legal moves for this specific piece and square\n    const legalMoves = gameCopy.moves({\n      square: sourceSquare,\n      verbose: true\n    });\n\n    // Find the EXACT matching move for the target square\n    const legalMove = legalMoves.find(move => move.to === targetSquare);\n    if (!legalMove) {\n      console.error(`${targetSquare} is not a legal target from ${sourceSquare}`);\n      return false;\n    }\n\n    // Apply the move using the complete move object, not just a string\n    try {\n      // Create the exact move object with promotion if needed\n      const moveObj = {\n        from: sourceSquare,\n        to: targetSquare,\n        promotion: legalMove.promotion || undefined\n      };\n      console.log(\"Move object being applied:\", moveObj);\n      const result = gameCopy.move(moveObj);\n      console.log(\"User intended move:\", moveObj);\n      console.log(\"Actual move applied:\", result);\n      console.log(\"New board position:\", gameCopy.fen());\n      if (!result) {\n        console.error(\"Failed to apply legal move:\", moveObj);\n        return false;\n      }\n\n      // Check if the piece ended up where the user intended\n      const pieceAtTarget = gameCopy.get(targetSquare);\n      console.log(\"Piece at target square after move:\", pieceAtTarget);\n      if (!pieceAtTarget || pieceAtTarget.type !== piece.type || pieceAtTarget.color !== piece.color) {\n        console.warn(\"Piece did not end up at the target square as expected!\");\n        console.warn(\"Original piece:\", piece);\n        console.warn(\"Piece at target:\", pieceAtTarget);\n        return false;\n      }\n      console.log(\"Direct move successfully applied:\", result);\n\n      // Update the game state with the successful move\n      setGame(gameCopy);\n\n      // Update move history\n      setMoveHistory(prev => [...prev, result.san]);\n\n      // Check if game is over\n      if (gameCopy.isGameOver()) {\n        handleGameOver();\n        return true;\n      }\n\n      // AI makes a move after a short delay\n      setTimeout(makeAIMove, 300);\n      return true;\n    } catch (error) {\n      console.error(\"Error making direct move:\", error);\n      return false;\n    }\n  }\n\n  // Handle piece drop from user\n  function onDrop(sourceSquare, targetSquare) {\n    // Only allow moves if it's the player's turn\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    if (currentTurn !== playerColor) {\n      console.log(\"Not your turn!\");\n      return false;\n    }\n    console.log(\"User attempting move from\", sourceSquare, \"to\", targetSquare);\n    console.log(\"Current board position:\", game.fen());\n    console.log(\"Piece being moved:\", game.get(sourceSquare));\n\n    // Show all legal moves from the source square for debugging\n    const legalMoves = showLegalMoves(sourceSquare);\n\n    // Check if the target square is a legal destination\n    const isLegalTarget = legalMoves.some(move => move.to === targetSquare);\n    console.log(`Is ${targetSquare} a legal target from ${sourceSquare}?`, isLegalTarget);\n    if (!isLegalTarget) {\n      console.error(`${targetSquare} is not a legal target from ${sourceSquare}`);\n      return false;\n    }\n\n    // Try the direct move approach first, which preserves the exact move\n    return directMove(sourceSquare, targetSquare);\n  }\n\n  // Make AI move\n  async function makeAIMove() {\n    setIsAIThinking(true);\n    console.log(\"AI is thinking...\");\n    const currentFEN = game.fen(); // Capture current FEN\n    console.log(\"Current FEN:\", currentFEN);\n    try {\n      // Call your FastAPI backend\n      const response = await fetch('http://localhost:8000/chess/get-move', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          fen: currentFEN\n        })\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Server responded with ${response.status}: ${errorText}`);\n      }\n      const data = await response.json();\n      console.log(\"AI selected move:\", data.move);\n\n      // Validate the move data\n      if (!data.move || !data.move.from || !data.move.to) {\n        throw new Error(\"Invalid move data received from AI: \" + JSON.stringify(data));\n      }\n\n      // Create a new game state from the current FEN\n      const gameCopy = new Chess(currentFEN);\n\n      // Get all legal moves from the source square\n      const legalMoves = gameCopy.moves({\n        square: data.move.from,\n        verbose: true\n      });\n      console.log(\"Legal moves from AI source square:\", legalMoves);\n\n      // Find the exact legal move that matches the AI's move\n      const legalMove = legalMoves.find(move => move.to === data.move.to);\n      if (legalMove) {\n        console.log(\"Found matching legal move for AI:\", legalMove);\n\n        // Apply the move using the exact legal move object\n        const result = gameCopy.move({\n          from: legalMove.from,\n          to: legalMove.to,\n          promotion: data.move.promotion || legalMove.promotion\n        });\n        if (result) {\n          console.log(\"AI move successfully applied:\", result);\n          console.log(\"New board position:\", gameCopy.fen());\n\n          // Update the game state with the successful move\n          setGame(gameCopy);\n\n          // Update move history\n          setMoveHistory(prev => [...prev, result.san]);\n\n          // Check if game is over after AI move\n          if (gameCopy.isGameOver()) {\n            handleGameOver();\n          }\n          setIsAIThinking(false);\n          return;\n        }\n      }\n\n      // If we couldn't find or apply the exact legal move, try fallback methods\n      console.error(\"Could not find or apply exact legal move for AI\");\n\n      // Try using the move object directly\n      const moveObj = {\n        from: data.move.from,\n        to: data.move.to\n      };\n      if (data.move.promotion) {\n        moveObj.promotion = data.move.promotion;\n      }\n      const result = gameCopy.move(moveObj);\n      if (!result) {\n        console.error(\"AI move is invalid:\", moveObj);\n\n        // Try to find a random legal move as fallback\n        if (legalMoves.length > 0) {\n          // Use a random legal move from the source square if available\n          const randomIndex = Math.floor(Math.random() * legalMoves.length);\n          const fallbackMove = legalMoves[randomIndex];\n          console.log(\"Making random move instead:\", fallbackMove);\n          const fallbackResult = gameCopy.move(fallbackMove);\n          if (fallbackResult) {\n            console.log(\"Random move applied:\", fallbackResult);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n            return;\n          }\n        }\n\n        // If we still can't make a move, try a random legal move from any piece\n        const allLegalMoves = game.moves({\n          verbose: true\n        });\n        if (allLegalMoves.length > 0) {\n          const randomIndex = Math.floor(Math.random() * allLegalMoves.length);\n          const randomMove = allLegalMoves[randomIndex];\n          console.log(\"Making random move instead:\", randomMove);\n          const randomResult = gameCopy.move(randomMove);\n          if (randomResult) {\n            console.log(\"Random move applied:\", randomResult);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n          }\n        }\n        return;\n      }\n      console.log(\"AI move applied using move object:\", result);\n\n      // Update the game state with the successful move\n      setGame(gameCopy);\n\n      // Update move history\n      setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n\n      // Check if game is over after AI move\n      if (gameCopy.isGameOver()) {\n        handleGameOver();\n      }\n    } catch (error) {\n      console.error('Error getting AI move:', error);\n      // If there's an error with the AI move, make a random legal move instead\n      try {\n        const gameCopy = new Chess(game.fen());\n        const legalMoves = gameCopy.moves({\n          verbose: true\n        });\n        if (legalMoves.length > 0) {\n          const randomIndex = Math.floor(Math.random() * legalMoves.length);\n          const randomMove = legalMoves[randomIndex];\n          console.log(\"Making random move instead:\", randomMove);\n          const result = gameCopy.move(randomMove);\n          if (result) {\n            console.log(\"Random move applied:\", result);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error(\"Failed to make fallback move:\", fallbackError);\n      }\n    } finally {\n      setIsAIThinking(false);\n    }\n  }\n\n  // Handle when game is over\n  function handleGameOver() {\n    let result = 'draw';\n    if (game.isCheckmate()) {\n      result = game.turn() === 'w' ? 'black' : 'white';\n    }\n    console.log(\"Game over! Result:\", result);\n\n    // Save game data\n    saveGameData(result);\n\n    // Notify parent component\n    if (onGameEnd) {\n      onGameEnd({\n        result,\n        pgn: game.pgn(),\n        history: moveHistory\n      });\n    }\n  }\n\n  // Save game data to backend\n  async function saveGameData(result) {\n    try {\n      await fetch('http://localhost:8000/chess/save-game', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          pgn: game.pgn(),\n          result: result\n        })\n      });\n    } catch (error) {\n      console.error('Error saving game:', error);\n    }\n  }\n\n  // Reset the game\n  function resetGame() {\n    setGame(new Chess());\n    setMoveHistory([]);\n\n    // If player is black, AI (white) should make the first move\n    if (playerColor === 'black') {\n      setTimeout(makeAIMove, 500);\n    }\n  }\n\n  // Toggle board orientation and player color\n  function flipBoard() {\n    const newOrientation = boardOrientation === 'white' ? 'black' : 'white';\n    setBoardOrientation(newOrientation);\n    setPlayerColor(newOrientation);\n\n    // Reset the game when switching sides\n    const newGame = new Chess();\n    setGame(newGame);\n    setMoveHistory([]);\n\n    // If player is now black, AI (white) should make the first move\n    if (newOrientation === 'black') {\n      setTimeout(makeAIMove, 500);\n    }\n  }\n\n  // Check if it's AI's turn when the component mounts or game state changes\n  useEffect(() => {\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n\n    // Log the current game state for debugging\n    console.log(\"Game state updated:\", {\n      fen: game.fen(),\n      turn: currentTurn,\n      playerColor: playerColor,\n      isAIThinking: isAIThinking,\n      isGameOver: game.isGameOver()\n    });\n\n    // If it's AI's turn and the game is not over\n    if (currentTurn !== playerColor && !game.isGameOver() && !isAIThinking) {\n      setTimeout(makeAIMove, 300);\n    }\n  }, [game, playerColor, isAIThinking]);\n\n  // Handle square click for click-to-move functionality\n  function onSquareClick(square) {\n    console.log(\"Square clicked:\", square);\n\n    // Only allow interaction when it's the player's turn\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    if (currentTurn !== playerColor) {\n      console.log(\"Not your turn!\");\n      return;\n    }\n\n    // If no square is selected yet, select this square if it has a piece of the player's color\n    if (!selectedSquare) {\n      const piece = game.get(square);\n      if (piece) {\n        const pieceColor = piece.color === 'w' ? 'white' : 'black';\n\n        // Only allow selecting pieces of the player's color\n        if (pieceColor === playerColor) {\n          setSelectedSquare(square);\n          console.log(\"Selected square:\", square);\n\n          // Get and show legal moves for the selected piece\n          const legalMoves = showLegalMoves(square);\n\n          // Create a map of legal target squares for highlighting\n          const legalSquares = {};\n          legalMoves.forEach(move => {\n            legalSquares[move.to] = {\n              background: 'radial-gradient(circle, rgba(0,0,0,.1) 25%, transparent 25%)',\n              borderRadius: '50%'\n            };\n          });\n\n          // Set the legal move squares for highlighting\n          setLegalMoveSquares(legalSquares);\n        } else {\n          console.log(\"Cannot select this piece - wrong color\");\n        }\n      } else {\n        console.log(\"No piece on this square to select\");\n      }\n      return;\n    }\n\n    // If a square is already selected, try to move from the selected square to this square\n    if (selectedSquare) {\n      console.log(`Attempting to move from ${selectedSquare} to ${square}`);\n      console.log(\"Current board position:\", game.fen());\n      console.log(\"Piece being moved:\", game.get(selectedSquare));\n\n      // If clicking the same square, deselect it\n      if (selectedSquare === square) {\n        console.log(\"Deselecting square\");\n        setSelectedSquare(null);\n        setLegalMoveSquares({});\n        return;\n      }\n\n      // Check if this is a legal move\n      const legalMoves = showLegalMoves(selectedSquare);\n      const isLegalTarget = legalMoves.some(move => move.to === square);\n      console.log(`Is ${square} a legal target from ${selectedSquare}?`, isLegalTarget);\n      if (!isLegalTarget) {\n        console.log(`${square} is not a legal target from ${selectedSquare}`);\n\n        // If the new square has a piece of the player's color, select it instead\n        const piece = game.get(square);\n        if (piece) {\n          const pieceColor = piece.color === 'w' ? 'white' : 'black';\n          if (pieceColor === playerColor) {\n            setSelectedSquare(square);\n            console.log(\"Selected new square:\", square);\n\n            // Update legal move highlights for the new selected piece\n            const newLegalMoves = showLegalMoves(square);\n            const newLegalSquares = {};\n            newLegalMoves.forEach(move => {\n              newLegalSquares[move.to] = {\n                background: 'radial-gradient(circle, rgba(0,0,0,.1) 25%, transparent 25%)',\n                borderRadius: '50%'\n              };\n            });\n            setLegalMoveSquares(newLegalSquares);\n            return;\n          }\n        }\n\n        // Otherwise, just clear the selection\n        setSelectedSquare(null);\n        setLegalMoveSquares({});\n        return false;\n      }\n\n      // Try to make the move\n      const result = directMove(selectedSquare, square);\n\n      // Clear selection and legal move highlights\n      setSelectedSquare(null);\n      setLegalMoveSquares({});\n      return result;\n    }\n  }\n\n  // Function to determine if a piece is draggable\n  function isDraggablePiece({\n    piece,\n    sourceSquare\n  }) {\n    // Only allow dragging pieces of the player's color\n    const pieceColor = piece.charAt(0).toLowerCase() === 'w' ? 'white' : 'black';\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n\n    // Only allow dragging if it's the player's turn and the piece is of the player's color\n    return currentTurn === playerColor && pieceColor === playerColor;\n  }\n\n  // Get custom square styles to highlight the selected square and legal moves\n  function getCustomSquareStyles() {\n    const combinedStyles = {\n      ...legalMoveSquares\n    };\n\n    // Add highlight for the selected square\n    if (selectedSquare) {\n      combinedStyles[selectedSquare] = {\n        backgroundColor: 'rgba(255, 255, 0, 0.4)'\n      };\n    }\n    return combinedStyles;\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chessboard-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"board\",\n      children: /*#__PURE__*/_jsxDEV(Chessboard, {\n        position: game.fen(),\n        onPieceDrop: onDrop,\n        boardOrientation: boardOrientation,\n        customBoardStyle: {\n          borderRadius: '5px',\n          boxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)'\n        },\n        arePiecesDraggable: true,\n        animationDuration: 200,\n        isDraggablePiece: isDraggablePiece,\n        onSquareClick: onSquareClick,\n        customSquareStyles: getCustomSquareStyles()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 539,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 538,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: resetGame,\n        children: \"New Game\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 556,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: flipBoard,\n        children: [\"Play as \", boardOrientation === 'white' ? 'Black' : 'White']\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 557,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 555,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-info\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"player-info\",\n        children: [\"Playing as: \", /*#__PURE__*/_jsxDEV(\"strong\", {\n          children: playerColor\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 562,\n          columnNumber: 23\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 561,\n        columnNumber: 9\n      }, this), isAIThinking && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"status\",\n        children: \"AI is thinking...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 564,\n        columnNumber: 26\n      }, this), game.isGameOver() && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"game-over\",\n        children: game.isCheckmate() ? `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins!` : 'Game ended in a draw'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 567,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 560,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 537,\n    columnNumber: 5\n  }, this);\n};\n_s(ChessBoard, \"QBx28ynDmaskdJvk4rKRr6Td/g0=\");\n_c = ChessBoard;\nexport default ChessBoard;\nvar _c;\n$RefreshReg$(_c, \"ChessBoard\");","map":{"version":3,"names":["React","useState","useEffect","Chessboard","Chess","jsxDEV","_jsxDEV","ChessBoard","onGameEnd","_s","game","setGame","boardOrientation","setBoardOrientation","isAIThinking","setIsAIThinking","moveHistory","setMoveHistory","playerColor","setPlayerColor","selectedSquare","setSelectedSquare","legalMoveSquares","setLegalMoveSquares","showLegalMoves","sourceSquare","legalMoves","moves","square","verbose","console","log","directMove","targetSquare","currentFEN","fen","gameCopy","piece","get","error","legalMove","find","move","to","moveObj","from","promotion","undefined","result","pieceAtTarget","type","color","warn","prev","san","isGameOver","handleGameOver","setTimeout","makeAIMove","onDrop","currentTurn","turn","isLegalTarget","some","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","Error","status","data","json","length","randomIndex","Math","floor","random","fallbackMove","fallbackResult","history","pop","allLegalMoves","randomMove","randomResult","fallbackError","isCheckmate","saveGameData","pgn","resetGame","flipBoard","newOrientation","newGame","onSquareClick","pieceColor","legalSquares","forEach","background","borderRadius","newLegalMoves","newLegalSquares","isDraggablePiece","charAt","toLowerCase","getCustomSquareStyles","combinedStyles","backgroundColor","className","children","position","onPieceDrop","customBoardStyle","boxShadow","arePiecesDraggable","animationDuration","customSquareStyles","fileName","_jsxFileName","lineNumber","columnNumber","onClick","_c","$RefreshReg$"],"sources":["/Users/bignola/Desktop/School/Capstone/AI-Chess-main/chess-ai-frontend/src/components/ChessBoard/ChessBoard.jsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { Chessboard } from 'react-chessboard';\nimport { Chess } from 'chess.js';\nimport './ChessBoard.css';\n\nconst ChessBoard = ({ onGameEnd }) => {\n  const [game, setGame] = useState(() => new Chess());\n  const [boardOrientation, setBoardOrientation] = useState('white');\n  const [isAIThinking, setIsAIThinking] = useState(false);\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [playerColor, setPlayerColor] = useState('white'); // Player plays as white by default\n  const [selectedSquare, setSelectedSquare] = useState(null);\n  const [legalMoveSquares, setLegalMoveSquares] = useState({});\n\n  // Debug function to show all legal moves from a position\n  function showLegalMoves(sourceSquare) {\n    if (!sourceSquare) return [];\n    \n    // Get all legal moves for the piece at the source square\n    const legalMoves = game.moves({\n      square: sourceSquare,\n      verbose: true\n    });\n    \n    console.log(`Legal moves from ${sourceSquare}:`, legalMoves);\n    return legalMoves;\n  }\n\n  // Function to directly apply a move without chess.js's move validation\n  // This is a last resort for when chess.js is changing the user's move\n  function directMove(sourceSquare, targetSquare) {\n    console.log(\"Attempting direct move from\", sourceSquare, \"to\", targetSquare);\n    \n    // Create a new game state from the current position\n    const currentFEN = game.fen();\n    const gameCopy = new Chess(currentFEN);\n    console.log(\"Starting position:\", currentFEN);\n    \n    // Get the piece at the source square\n    const piece = gameCopy.get(sourceSquare);\n    if (!piece) {\n      console.error(\"No piece at source square:\", sourceSquare);\n      return false;\n    }\n    \n    // Get all legal moves for this specific piece and square\n    const legalMoves = gameCopy.moves({\n      square: sourceSquare,\n      verbose: true\n    });\n    \n    // Find the EXACT matching move for the target square\n    const legalMove = legalMoves.find(move => move.to === targetSquare);\n    if (!legalMove) {\n      console.error(`${targetSquare} is not a legal target from ${sourceSquare}`);\n      return false;\n    }\n    \n    // Apply the move using the complete move object, not just a string\n    try {\n      // Create the exact move object with promotion if needed\n      const moveObj = {\n        from: sourceSquare,\n        to: targetSquare,\n        promotion: legalMove.promotion || undefined\n      };\n      \n      console.log(\"Move object being applied:\", moveObj);\n      \n      const result = gameCopy.move(moveObj);\n      console.log(\"User intended move:\", moveObj);\n      console.log(\"Actual move applied:\", result);\n      console.log(\"New board position:\", gameCopy.fen());\n      \n      if (!result) {\n        console.error(\"Failed to apply legal move:\", moveObj);\n        return false;\n      }\n      \n      // Check if the piece ended up where the user intended\n      const pieceAtTarget = gameCopy.get(targetSquare);\n      console.log(\"Piece at target square after move:\", pieceAtTarget);\n      \n      if (!pieceAtTarget || pieceAtTarget.type !== piece.type || pieceAtTarget.color !== piece.color) {\n        console.warn(\"Piece did not end up at the target square as expected!\");\n        console.warn(\"Original piece:\", piece);\n        console.warn(\"Piece at target:\", pieceAtTarget);\n        return false;\n      }\n      \n      console.log(\"Direct move successfully applied:\", result);\n      \n      // Update the game state with the successful move\n      setGame(gameCopy);\n      \n      // Update move history\n      setMoveHistory(prev => [...prev, result.san]);\n      \n      // Check if game is over\n      if (gameCopy.isGameOver()) {\n        handleGameOver();\n        return true;\n      }\n      \n      // AI makes a move after a short delay\n      setTimeout(makeAIMove, 300);\n      return true;\n    } catch (error) {\n      console.error(\"Error making direct move:\", error);\n      return false;\n    }\n  }\n\n  // Handle piece drop from user\n  function onDrop(sourceSquare, targetSquare) {\n    // Only allow moves if it's the player's turn\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    if (currentTurn !== playerColor) {\n      console.log(\"Not your turn!\");\n      return false;\n    }\n\n    console.log(\"User attempting move from\", sourceSquare, \"to\", targetSquare);\n    console.log(\"Current board position:\", game.fen());\n    console.log(\"Piece being moved:\", game.get(sourceSquare));\n    \n    // Show all legal moves from the source square for debugging\n    const legalMoves = showLegalMoves(sourceSquare);\n    \n    // Check if the target square is a legal destination\n    const isLegalTarget = legalMoves.some(move => move.to === targetSquare);\n    console.log(`Is ${targetSquare} a legal target from ${sourceSquare}?`, isLegalTarget);\n    \n    if (!isLegalTarget) {\n      console.error(`${targetSquare} is not a legal target from ${sourceSquare}`);\n      return false;\n    }\n    \n    // Try the direct move approach first, which preserves the exact move\n    return directMove(sourceSquare, targetSquare);\n  }\n\n  // Make AI move\n  async function makeAIMove() {\n    setIsAIThinking(true);\n    console.log(\"AI is thinking...\");\n    const currentFEN = game.fen();  // Capture current FEN\n    console.log(\"Current FEN:\", currentFEN);\n\n    try {\n      // Call your FastAPI backend\n      const response = await fetch('http://localhost:8000/chess/get-move', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ fen: currentFEN }),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Server responded with ${response.status}: ${errorText}`);\n      }\n\n      const data = await response.json();\n      console.log(\"AI selected move:\", data.move);\n      \n      // Validate the move data\n      if (!data.move || !data.move.from || !data.move.to) {\n        throw new Error(\"Invalid move data received from AI: \" + JSON.stringify(data));\n      }\n      \n      // Create a new game state from the current FEN\n      const gameCopy = new Chess(currentFEN);\n      \n      // Get all legal moves from the source square\n      const legalMoves = gameCopy.moves({\n        square: data.move.from,\n        verbose: true\n      });\n      \n      console.log(\"Legal moves from AI source square:\", legalMoves);\n      \n      // Find the exact legal move that matches the AI's move\n      const legalMove = legalMoves.find(move => move.to === data.move.to);\n      \n      if (legalMove) {\n        console.log(\"Found matching legal move for AI:\", legalMove);\n        \n        // Apply the move using the exact legal move object\n        const result = gameCopy.move({\n          from: legalMove.from,\n          to: legalMove.to,\n          promotion: data.move.promotion || legalMove.promotion\n        });\n        \n        if (result) {\n          console.log(\"AI move successfully applied:\", result);\n          console.log(\"New board position:\", gameCopy.fen());\n          \n          // Update the game state with the successful move\n          setGame(gameCopy);\n          \n          // Update move history\n          setMoveHistory(prev => [...prev, result.san]);\n          \n          // Check if game is over after AI move\n          if (gameCopy.isGameOver()) {\n            handleGameOver();\n          }\n          \n          setIsAIThinking(false);\n          return;\n        }\n      }\n      \n      // If we couldn't find or apply the exact legal move, try fallback methods\n      console.error(\"Could not find or apply exact legal move for AI\");\n      \n      // Try using the move object directly\n      const moveObj = {\n        from: data.move.from,\n        to: data.move.to\n      };\n      \n      if (data.move.promotion) {\n        moveObj.promotion = data.move.promotion;\n      }\n      \n      const result = gameCopy.move(moveObj);\n      \n      if (!result) {\n        console.error(\"AI move is invalid:\", moveObj);\n        \n        // Try to find a random legal move as fallback\n        if (legalMoves.length > 0) {\n          // Use a random legal move from the source square if available\n          const randomIndex = Math.floor(Math.random() * legalMoves.length);\n          const fallbackMove = legalMoves[randomIndex];\n          console.log(\"Making random move instead:\", fallbackMove);\n          \n          const fallbackResult = gameCopy.move(fallbackMove);\n          if (fallbackResult) {\n            console.log(\"Random move applied:\", fallbackResult);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            \n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n            return;\n          }\n        }\n        \n        // If we still can't make a move, try a random legal move from any piece\n        const allLegalMoves = game.moves({ verbose: true });\n        if (allLegalMoves.length > 0) {\n          const randomIndex = Math.floor(Math.random() * allLegalMoves.length);\n          const randomMove = allLegalMoves[randomIndex];\n          console.log(\"Making random move instead:\", randomMove);\n          \n          const randomResult = gameCopy.move(randomMove);\n          if (randomResult) {\n            console.log(\"Random move applied:\", randomResult);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            \n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n          }\n        }\n        return;\n      }\n      \n      console.log(\"AI move applied using move object:\", result);\n      \n      // Update the game state with the successful move\n      setGame(gameCopy);\n      \n      // Update move history\n      setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n      \n      // Check if game is over after AI move\n      if (gameCopy.isGameOver()) {\n        handleGameOver();\n      }\n    } catch (error) {\n      console.error('Error getting AI move:', error);\n      // If there's an error with the AI move, make a random legal move instead\n      try {\n        const gameCopy = new Chess(game.fen());\n        const legalMoves = gameCopy.moves({ verbose: true });\n        if (legalMoves.length > 0) {\n          const randomIndex = Math.floor(Math.random() * legalMoves.length);\n          const randomMove = legalMoves[randomIndex];\n          console.log(\"Making random move instead:\", randomMove);\n          \n          const result = gameCopy.move(randomMove);\n          if (result) {\n            console.log(\"Random move applied:\", result);\n            setGame(gameCopy);\n            setMoveHistory([...moveHistory, gameCopy.history().pop()]);\n            \n            if (gameCopy.isGameOver()) {\n              handleGameOver();\n            }\n          }\n        }\n      } catch (fallbackError) {\n        console.error(\"Failed to make fallback move:\", fallbackError);\n      }\n    } finally {\n      setIsAIThinking(false);\n    }\n  }\n\n  // Handle when game is over\n  function handleGameOver() {\n    let result = 'draw';\n    if (game.isCheckmate()) {\n      result = game.turn() === 'w' ? 'black' : 'white';\n    }\n\n    console.log(\"Game over! Result:\", result);\n\n    // Save game data\n    saveGameData(result);\n    \n    // Notify parent component\n    if (onGameEnd) {\n      onGameEnd({\n        result,\n        pgn: game.pgn(),\n        history: moveHistory,\n      });\n    }\n  }\n\n  // Save game data to backend\n  async function saveGameData(result) {\n    try {\n      await fetch('http://localhost:8000/chess/save-game', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          pgn: game.pgn(),\n          result: result,\n        }),\n      });\n    } catch (error) {\n      console.error('Error saving game:', error);\n    }\n  }\n\n  // Reset the game\n  function resetGame() {\n    setGame(new Chess());\n    setMoveHistory([]);\n    \n    // If player is black, AI (white) should make the first move\n    if (playerColor === 'black') {\n      setTimeout(makeAIMove, 500);\n    }\n  }\n\n  // Toggle board orientation and player color\n  function flipBoard() {\n    const newOrientation = boardOrientation === 'white' ? 'black' : 'white';\n    setBoardOrientation(newOrientation);\n    setPlayerColor(newOrientation);\n    \n    // Reset the game when switching sides\n    const newGame = new Chess();\n    setGame(newGame);\n    setMoveHistory([]);\n    \n    // If player is now black, AI (white) should make the first move\n    if (newOrientation === 'black') {\n      setTimeout(makeAIMove, 500);\n    }\n  }\n\n  // Check if it's AI's turn when the component mounts or game state changes\n  useEffect(() => {\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    \n    // Log the current game state for debugging\n    console.log(\"Game state updated:\", {\n      fen: game.fen(),\n      turn: currentTurn,\n      playerColor: playerColor,\n      isAIThinking: isAIThinking,\n      isGameOver: game.isGameOver()\n    });\n    \n    // If it's AI's turn and the game is not over\n    if (currentTurn !== playerColor && !game.isGameOver() && !isAIThinking) {\n      setTimeout(makeAIMove, 300);\n    }\n  }, [game, playerColor, isAIThinking]);\n\n  // Handle square click for click-to-move functionality\n  function onSquareClick(square) {\n    console.log(\"Square clicked:\", square);\n    \n    // Only allow interaction when it's the player's turn\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    if (currentTurn !== playerColor) {\n      console.log(\"Not your turn!\");\n      return;\n    }\n    \n    // If no square is selected yet, select this square if it has a piece of the player's color\n    if (!selectedSquare) {\n      const piece = game.get(square);\n      if (piece) {\n        const pieceColor = piece.color === 'w' ? 'white' : 'black';\n        \n        // Only allow selecting pieces of the player's color\n        if (pieceColor === playerColor) {\n          setSelectedSquare(square);\n          console.log(\"Selected square:\", square);\n          \n          // Get and show legal moves for the selected piece\n          const legalMoves = showLegalMoves(square);\n          \n          // Create a map of legal target squares for highlighting\n          const legalSquares = {};\n          legalMoves.forEach(move => {\n            legalSquares[move.to] = {\n              background: 'radial-gradient(circle, rgba(0,0,0,.1) 25%, transparent 25%)',\n              borderRadius: '50%'\n            };\n          });\n          \n          // Set the legal move squares for highlighting\n          setLegalMoveSquares(legalSquares);\n        } else {\n          console.log(\"Cannot select this piece - wrong color\");\n        }\n      } else {\n        console.log(\"No piece on this square to select\");\n      }\n      return;\n    }\n    \n    // If a square is already selected, try to move from the selected square to this square\n    if (selectedSquare) {\n      console.log(`Attempting to move from ${selectedSquare} to ${square}`);\n      console.log(\"Current board position:\", game.fen());\n      console.log(\"Piece being moved:\", game.get(selectedSquare));\n      \n      // If clicking the same square, deselect it\n      if (selectedSquare === square) {\n        console.log(\"Deselecting square\");\n        setSelectedSquare(null);\n        setLegalMoveSquares({});\n        return;\n      }\n      \n      // Check if this is a legal move\n      const legalMoves = showLegalMoves(selectedSquare);\n      const isLegalTarget = legalMoves.some(move => move.to === square);\n      console.log(`Is ${square} a legal target from ${selectedSquare}?`, isLegalTarget);\n      \n      if (!isLegalTarget) {\n        console.log(`${square} is not a legal target from ${selectedSquare}`);\n        \n        // If the new square has a piece of the player's color, select it instead\n        const piece = game.get(square);\n        if (piece) {\n          const pieceColor = piece.color === 'w' ? 'white' : 'black';\n          if (pieceColor === playerColor) {\n            setSelectedSquare(square);\n            console.log(\"Selected new square:\", square);\n            \n            // Update legal move highlights for the new selected piece\n            const newLegalMoves = showLegalMoves(square);\n            const newLegalSquares = {};\n            newLegalMoves.forEach(move => {\n              newLegalSquares[move.to] = {\n                background: 'radial-gradient(circle, rgba(0,0,0,.1) 25%, transparent 25%)',\n                borderRadius: '50%'\n              };\n            });\n            \n            setLegalMoveSquares(newLegalSquares);\n            return;\n          }\n        }\n        \n        // Otherwise, just clear the selection\n        setSelectedSquare(null);\n        setLegalMoveSquares({});\n        return false;\n      }\n      \n      // Try to make the move\n      const result = directMove(selectedSquare, square);\n      \n      // Clear selection and legal move highlights\n      setSelectedSquare(null);\n      setLegalMoveSquares({});\n      \n      return result;\n    }\n  }\n\n  // Function to determine if a piece is draggable\n  function isDraggablePiece({ piece, sourceSquare }) {\n    // Only allow dragging pieces of the player's color\n    const pieceColor = piece.charAt(0).toLowerCase() === 'w' ? 'white' : 'black';\n    const currentTurn = game.turn() === 'w' ? 'white' : 'black';\n    \n    // Only allow dragging if it's the player's turn and the piece is of the player's color\n    return currentTurn === playerColor && pieceColor === playerColor;\n  }\n\n  // Get custom square styles to highlight the selected square and legal moves\n  function getCustomSquareStyles() {\n    const combinedStyles = { ...legalMoveSquares };\n    \n    // Add highlight for the selected square\n    if (selectedSquare) {\n      combinedStyles[selectedSquare] = {\n        backgroundColor: 'rgba(255, 255, 0, 0.4)',\n      };\n    }\n    \n    return combinedStyles;\n  }\n\n  return (\n    <div className=\"chessboard-container\">\n      <div className=\"board\">\n        <Chessboard \n          position={game.fen()} \n          onPieceDrop={onDrop} \n          boardOrientation={boardOrientation}\n          customBoardStyle={{\n            borderRadius: '5px',\n            boxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)'\n          }}\n          arePiecesDraggable={true}\n          animationDuration={200}\n          isDraggablePiece={isDraggablePiece}\n          onSquareClick={onSquareClick}\n          customSquareStyles={getCustomSquareStyles()}\n        />\n      </div>\n      \n      <div className=\"controls\">\n        <button onClick={resetGame}>New Game</button>\n        <button onClick={flipBoard}>Play as {boardOrientation === 'white' ? 'Black' : 'White'}</button>\n      </div>\n      \n      <div className=\"game-info\">\n        <div className=\"player-info\">\n          Playing as: <strong>{playerColor}</strong>\n        </div>\n        {isAIThinking && <div className=\"status\">AI is thinking...</div>}\n        \n        {game.isGameOver() && (\n          <div className=\"game-over\">\n            {game.isCheckmate() \n              ? `Checkmate! ${game.turn() === 'w' ? 'Black' : 'White'} wins!` \n              : 'Game ended in a draw'}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ChessBoard;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}